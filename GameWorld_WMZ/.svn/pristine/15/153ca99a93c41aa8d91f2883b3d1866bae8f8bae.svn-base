#include "gamehoster.h"
#include <iostream>
#include <QList>
#include <QDataStream>
#include <QDebug>
#include <QNetworkInterface>
#include <QTcpSocket>
#include <QPixmap>
#include "gameclient.h"

GameHoster *GameHoster::_instance = 0;

GameHoster::GameHoster(Room room)
{

    this->_broadcaster = new QUdpSocket();
    this->_room = room;

    this->_server = new QTcpServer();
    QObject::connect(_server, SIGNAL(newConnection()), this , SLOT(newClientConnection()));
    if (!this->_server->listen(this->_room.senderAddress, TCP_CONNECTION_PORT)) {

        qDebug() << "Can not open the server";
    }

    QPixmap worldMap;
    if (room.map == 1) {

        worldMap = QPixmap(":/world/world.jpg");
    } else if (room.map == 2) {

        worldMap = QPixmap(":/world/world.jpg");
    } else if (room.map == 3) {

        worldMap = QPixmap(":/world/world.jpg");
    }

    _worldWidth = worldMap.width();
    _worldHeight = worldMap.height();

    QObject::connect(this, SIGNAL(needSendBroadcast()), this, SLOT(sendBroadcast()));
    this->start();

}

void GameHoster::run()
{
    while (this->_isBroadcasting) {

        this->sleep(1);

        emit needSendBroadcast();




    }
}

void GameHoster::assignRoles(int round)
{

    if (round == 1) {


        //request heros first

        for (QTcpSocket *socket : _clientSockets) {

            int16_t x;
            int16_t y;
            bool validCoor = false;
            while (!validCoor) {

                x = rand() % _worldWidth;
                y = rand() % _worldHeight;
                validCoor = true;

                for (QPoint &point : _roleCoors) {

                    if ((point.rx() == x) && (point.ry() == y)) {
                        validCoor = false;
                        break;
                    }
                }
            }

            _roleCoors.push_back(QPoint(x, y));

            QByteArray hero;
            QDataStream heroStream(&hero, QIODevice::WriteOnly);
            int16_t type = TCP_DATA_TYPE_HERO_REQUEST;
            int16_t size = 2 * sizeof(int16_t);
            heroStream << type << size << x << y;
            socket->write(hero.data(), hero.size());

        }

        for (QTcpSocket *socket : _clientSockets) {

            //for the first round, we let each client to create 2 opponents of type 1

            for (int i = 0; i < 2; i++) {

                int16_t x;
                int16_t y;
                bool validCoor = false;
                while (!validCoor) {

                    x = rand() % _worldWidth;
                    y = rand() % _worldHeight;
                    validCoor = true;

                    for (QPoint &point : _roleCoors) {

                        if ((point.rx() == x) && (point.ry() == y)) {
                            validCoor = false;
                            break;
                        }
                    }
                }

                _roleCoors.push_back(QPoint(x, y));

                QByteArray opponent;
                QDataStream opponentStream(&opponent, QIODevice::WriteOnly);
                int16_t type = TCP_DATA_TYPE_OPPONENT_REQUEST;
                int16_t size = sizeof(int16_t) * 3;
                int16_t opponentType = 1;
                opponentStream << type << size << opponentType << x << y;
                socket->write(opponent.data(), opponent.size());
                socket->flush();
            }

        }
    }
}


void GameHoster::CreateHoster(Room room)
{
    GameHoster::_instance = new GameHoster(room);

}

void GameHoster::DestoryHoser()
{

}

GameHoster *GameHoster::Instance()
{
    return GameHoster::_instance;
}

void GameHoster::sendBroadcast()
{

    QByteArray broadcastData;
    QDataStream dataStream(&broadcastData, QIODevice::WriteOnly);
    dataStream << _room;


    this->_broadcaster->writeDatagram(broadcastData.data(), broadcastData.size(), QHostAddress::Broadcast, BROADCAST_PORT);
    this->_broadcaster->writeDatagram(broadcastData.data(), broadcastData.size(), QHostAddress::Broadcast, BROADCAST_PORT);



}

void GameHoster::newClientConnection()
{

    qDebug() << "new tcp connection";
    QTcpSocket *clientSocket = this->_server->nextPendingConnection();
    QObject::connect(clientSocket, SIGNAL(readyRead()), this, SLOT(readData()));

    //send back the id of this connection
    int id = clientSocket->socketDescriptor();
    int16_t type= TCP_DATA_TYPE_CON_ID;
    int16_t size = sizeof(int);
    QByteArray data;
    QDataStream dataStream(&data, QIODevice::WriteOnly);
    dataStream << type << size << id;
    clientSocket->write(data.data(), data.size());

    this->_clientSockets.push_back(clientSocket);

}

void GameHoster::readData()
{


    //check which socket has data
    for (QTcpSocket *socket : _clientSockets) {

        while (socket->bytesAvailable()) {
            //read out the data
            QByteArray headerData;
            headerData.resize(sizeof(int16_t) * 2);
            socket->read(headerData.data(), sizeof(int16_t) * 2);
            QDataStream headerDataStream(&headerData, QIODevice::ReadOnly);
            int16_t type;
            int16_t size;
            headerDataStream >> type;
            headerDataStream >> size;

            QByteArray data;
            data.resize(size);
            socket->read(data.data(), size);
            QDataStream dataStream(&data, QIODevice::ReadOnly);

            if (type == TCP_DATA_TYPE_PLAYER) {

                //read out this player
                Player player;
                dataStream >> player;
                bool foundPlayer = false;
                for (Player &myPlayer : _players) {

                    if (myPlayer.id == player.id) {

                        myPlayer = player;
                        foundPlayer = true;
                        break;
                    }
                }
                if (!foundPlayer) {
                    _players.push_back(player); //add the new player the vector
                    _clientStates.push_back(CLIENT_STATE_ID_RECEIVED); //add the corronsponding client state
                }

                //give this information other sockets
                for (QTcpSocket *socket : _clientSockets) {

                    if (socket->socketDescriptor() != player.id) {
                        QByteArray data;
                        QDataStream dataStream(&data, QIODevice::WriteOnly);
                        dataStream << type << size << player;
                        socket->write(data.data(), data.size());
                    }
                }
            } else if (type == TCP_DATA_TYPE_QUERY_PLAYERS) {

                qDebug() << "request received";

                for (Player &player : _players) {

                    int16_t type = TCP_DATA_TYPE_PLAYER;
                    int16_t size = player.getByteSize();
                    QByteArray playerData;
                    QDataStream playerStream(&playerData, QIODevice::WriteOnly);
                    playerStream << type << size << player;
                    socket->write(playerData.data(), playerData.size());
                }
            } else if (type == TCP_DATA_TYPE_WORLD_CREATED) {

                //then we need assign roles for each client.
                for (int i = 0; i < _players.size(); i++) {
                    if (_players[i].id == socket->socketDescriptor()) {
                        _clientStates[i] = CLIENT_STATE_WORLD_READY;
                    }
                }

                //check if world ready for every one
                bool allReady = true;
                for (int state : _clientStates) {
                    if (state != CLIENT_STATE_WORLD_READY) allReady = false;
                }

                if (allReady) {

                    this->assignRoles(1);
                }
            } else if (type == TCP_DATA_TYPE_NEW_HERO) {

                HeroModel hero;
                dataStream >> hero;

                this->_heros.push_back(hero);

                //send the new hero to all other player
                for (QTcpSocket *mySocket : _clientSockets) {

                    if (socket->socketDescriptor() != mySocket->socketDescriptor()) {

                        QByteArray heroData;
                        QDataStream heroStream(&heroData, QIODevice::WriteOnly);
                        int16_t type = TCP_DATA_TYPE_NEW_HERO;
                        int16_t size = hero.getByteSize();
                        heroStream << type << size << hero;
                        mySocket->write(heroData.data(), heroData.size());
                        mySocket->flush();
                    }
                }
            } else if (type == TCP_DATA_TYPE_HERO_MOVE) {

                int16_t id;
                int16_t x;
                int16_t y;
                dataStream >> id >> x >> y;
                for (HeroModel &hero : _heros) {

                    if (hero.id == id) {
                        hero.x = x;
                        hero.y = y;
                    }
                }

                for (QTcpSocket *mySocket : _clientSockets) {

                    if (mySocket->socketDescriptor() != socket->socketDescriptor()) {

                        QByteArray moveData;
                        QDataStream moveStream(&moveData, QIODevice::WriteOnly);
                        moveStream << type << size << id << x << y;
                        mySocket->write(moveData.data(), moveData.size());
                        mySocket->flush();
                    }
                }
            } else if (type == TCP_DATA_TYPE_HERO_MOVING_STOPED) {

                int16_t id;
                dataStream >> id;

                for (QTcpSocket *mySocket : _clientSockets) {

                    if (mySocket->socketDescriptor() != socket->socketDescriptor()) {

                        QByteArray movingStoped;
                        QDataStream movingStopedStream;
                        movingStopedStream << type << size << id;
                        mySocket->write(movingStoped.data(), movingStoped.size());
                        mySocket->flush();
                    }
                }
            } else if (type == TCP_DATA_TYPE_NEW_OPPONENT) {

                OpponentModel opponent;
                dataStream >> opponent;

                _opponents.push_back(opponent);

                for (QTcpSocket *mySocket : _clientSockets) {

                    if (socket->socketDescriptor() != mySocket->socketDescriptor()) {

                        QByteArray opponentData;
                        QDataStream opponentStream(&opponentData, QIODevice::WriteOnly);
                        opponentStream << type << size << opponent;
                        mySocket->write(opponentData.data(), opponentData.size());
                        mySocket->flush();
                    }
                }
            }
        }

    }
}

void GameHoster::startGame()
{

    qDebug() << "Server: starting game";

    // send to all clients to start the game

    QByteArray startGame;
    QDataStream startStream(&startGame, QIODevice::WriteOnly);
    int16_t type = TCP_DATA_TYPE_NEED_CREATE_WORLD;
    int16_t size = 0;
    startStream << type << size;

    for (QTcpSocket *socket : _clientSockets) {

        socket->write(startGame.data(), startGame.size());
    }


}


//free functions

QDataStream & operator >> ( QDataStream & stream, Room & room )
{
        quint32 ipAddress;
        stream >> ipAddress;
        room.senderAddress = QHostAddress(ipAddress);
        stream >> room.roomName;
        stream >> room.map;
        stream >> room.maxPlayerNum;
        stream >> room.currentPlayerNum;

        return stream;
}

QDataStream & operator << ( QDataStream & stream, Room & room )
{
        stream << room.senderAddress.toIPv4Address();
        stream << room.roomName;
        stream << room.map;
        stream << room.maxPlayerNum;
        stream << room.currentPlayerNum;
        return stream;
}


QDataStream & operator >> ( QDataStream & stream, Player & player) {

    stream >> player.id;
    stream >> player.playerName;
    stream >> player.role;

    return stream;
}

QDataStream & operator << ( QDataStream & stream, Player & player) {

    stream << player.id;
    stream << player.playerName;
    stream << player.role;

    return stream;
}

QDataStream & operator >> ( QDataStream & stream, HeroModel & hero) {

    stream >> hero.id;
    stream >> hero.role;
    stream >> hero.x;
    stream >> hero.y;
    stream >> hero.healthPercentage;
    stream >> hero.magicPercentage;

    return stream;
}

QDataStream & operator << ( QDataStream & stream, HeroModel & hero) {

    stream << hero.id;
    stream << hero.role;
    stream << hero.x;
    stream << hero.y;
    stream << hero.healthPercentage;
    stream << hero.magicPercentage;

    return stream;
}

QDataStream & operator >> ( QDataStream & stream, OpponentModel & opponent) {

    stream >> opponent.id;
    stream >> opponent.type;
    stream >> opponent.x;
    stream >> opponent.y;
    stream >> opponent.healthPecentage;

    return stream;
}

QDataStream & operator << ( QDataStream & stream, OpponentModel & opponent ) {

    stream << opponent.id;
    stream << opponent.type;
    stream << opponent.x;
    stream << opponent.y;
    stream << opponent.healthPecentage;

    return stream;
}
